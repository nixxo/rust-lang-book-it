## `Rc<T>`, il Puntatore Intelligente con Conteggio dei Riferimenti

Nella maggior parte dei casi, la proprietà è chiara: si sa esattamente quale variabile
possiede un dato valore. Tuttavia, ci sono casi in cui un singolo valore potrebbe avere
più proprietari. Ad esempio, nelle strutture dati dei grafi, più archi potrebbero
puntare allo stesso nodo, e quel nodo è concettualmente di proprietà di tutti gli archi
che puntano ad esso. Un nodo non dovrebbe essere ripulito a meno che non abbia più
archi che puntano ad esso e quindi non abbia proprietari.

È necessario abilitare esplicitamente la proprietà multipla utilizzando il tipo Rust
`Rc<T>`, che è l'abbreviazione di _conteggio dei riferimenti _ (_reference counting_). Il tipo `Rc<T>`
tiene traccia del numero di riferimenti a un valore per determinare se
il valore è ancora in uso. Se non ci sono riferimenti a un valore, il valore
può essere ripulito senza che alcun riferimento diventi invalido.

Immaginate `Rc<T>` come una TV in un soggiorno. Quando una persona entra per guardare la TV,
la accende. Altri possono entrare nella stanza e guardare la TV. Quando l'ultima
persona esce dalla stanza, spegne la TV perché non la sta più utilizzando.
Se qualcuno spegne la TV mentre altri la stanno ancora guardando, ci sarebbe
un putiferio da parte degli altri spettatori!

Usiamo il tipo `Rc<T>` quando vogliamo allocare alcuni dati sull'heap affinché
più parti del nostro programma possano leggerli e non possiamo determinare in fase di compilazione
quale parte terminerà l'utilizzo dei dati per ultima. Se sapessimo quale parte terminerà
per ultima, potremmo semplicemente impostare quella parte come proprietaria dei dati e le normali regole di proprietà applicate che entrerebbero in vigore in fase di compilazione.

Si noti che `Rc<T>` è utilizzabile solo in scenari a thread singolo. Quando parleremo
di concorrenza nel Capitolo 16, spiegheremo come eseguire il conteggio dei riferimenti nei
programmi multithread.

### Utilizzo di `Rc<T>` per Condividere i Dati

Torniamo al nostro esempio di elenco cons nel Listato 15-5. Ricordiamo che lo abbiamo definito
utilizzando `Box<T>`. Questa volta creeremo due elenchi che condividono la proprietà
di un terzo elenco. Concettualmente, questo è simile alla Figura 15-3.

<img alt="Una lista concatenata con etichetta 'a' che punta a tre elementi: il primo elemento contiene l'intero 5 e punta al secondo elemento. Il secondo elemento contiene l'intero 10 e punta al terzo elemento. Il terzo elemento contiene il valore 'Nil' che indica la fine della lista; non punta da nessuna parte. Una lista concatenata con etichetta 'b' punta a un elemento che contiene l'intero 3 e punta al primo elemento della lista 'a'. Una lista concatenata con etichetta 'c' punta a un elemento che contiene l'intero 4 e punta anche al primo elemento della lista 'a', in modo che la coda delle liste 'b' e 'c' sia entrambe la lista 'a'" src="img/trpl15-03.svg" class="center" />

<span class="caption">Figura 15-3: Due liste, `b` e `c`, che condividono la proprietà di
una terza lista, `a`

Creeremo la lista `a` che contiene `5` e poi `10`. Quindi creeremo altre due liste: `b` che inizia con `3` e `c` che inizia con `4`. Entrambe le liste `b` e `c`
proseguiranno quindi con la prima lista `a` contenente `5` e `10`. In altre parole, entrambe le liste condivideranno la prima lista contenente `5` e `10`.

Cercare di implementare questo scenario utilizzando la nostra definizione di `List` con `Box<T>`
non funzionerà, come mostrato nel Listato 15-17.

<Listing number="15-17" file-name="src/main.rs" caption="Dimostrazione che non è consentito avere due liste che utilizzano `Box<T>` che tentano di condividere la proprietà di una terza lista">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-17/src/main.rs}}
```

</Listing>

Quando compiliamo questo codice, otteniamo questo errore:

```console
{{#include ../listings/ch15-smart-pointers/listing-15-17/output.txt}}
```

Le varianti `Cons` possiedono i dati che contengono, quindi quando creiamo la lista `b`, `a`
viene spostata in `b` e `b` possiede `a`. Quindi, quando proviamo a usare di nuovo `a` durante
la creazione di `c`, non ci viene consentito perché `a` è stato spostato.

Potremmo modificare la definizione di `Cons` per contenere invece i riferimenti, ma in tal caso
dovremmo specificare i parametri di lifetime. Specificando i parametri di durata,
specificheremmo che ogni elemento della lista vivrà almeno quanto l'intera lista. Questo vale per gli elementi e le liste
nel Listato 15-17, ma non in tutti gli scenari.

Invece, modificheremo la nostra definizione di `List` per usare `Rc<T>` al posto di
`Box<T>`, come mostrato nel Listato 15-18. Ogni variante di `Cons` ora conterrà un valore
e un `Rc<T>` che punta a una `List`. Quando creiamo `b`, invece di assumere
la proprietà di `a`, cloneremo `Rc<List>` che detiene `a`,
aumentando così il numero di riferimenti da uno a due e lasciando che `a` e `b`
condividano la proprietà dei dati in quella `Rc<List>`. Cloneremo anche `a` quando
creiamo `c`, aumentando il numero di riferimenti da due a tre. Ogni volta che
chiamiamo `Rc::clone`, il conteggio dei riferimenti ai dati all'interno di `Rc<List>` aumenterà
e i dati non verranno ripuliti a meno che non ci siano zero riferimenti ad essi.

<Listing number="15-18" file-name="src/main.rs" caption="A definition of `List` that uses `Rc<T>`">

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-18/src/main.rs}}
```

</Listing>

Dobbiamo aggiungere un'istruzione `use` per portare `Rc<T>` nell'ambito perché non è
nel prelude. In `main`, creiamo la lista contenente `5` e `10` e la memorizziamo
in una nuova `Rc<List>` in `a`. Quindi, quando creiamo `b` e `c`, chiamiamo la funzione
`Rc::clone` e passiamo un riferimento a `Rc<List>` in `a` come
argomento.

Avremmo potuto chiamare `a.clone()` invece di `Rc::clone(&a)`, ma la convenzione di Rust
in questo caso prevede di usare `Rc::clone`. L'implementazione di
`Rc::clone` non esegue una copia approfondita di tutti i dati come fanno la maggior parte delle implementazioni di `clone`
dei tipi. La chiamata a `Rc::clone` incrementa solo il
conteggio dei riferimenti, il che non richiede molto tempo. Le copie profonde dei dati possono richiedere
molto tempo. Utilizzando `Rc::clone` per il conteggio dei riferimenti, possiamo distinguere visivamente
tra i tipi di cloni che eseguono copie complete e quelli che
aumentano il conteggio dei riferimenti. Quando cerchiamo problemi di prestazioni nel
codice, dobbiamo considerare solo i cloni che eseguono copie complete e possiamo ignorare le chiamate a
`Rc::clone`.

### Clonare un `Rc<T>` Sumenta il Conteggio dei Riferimenti

Modifichiamo il nostro esempio di lavoro nel Listato 15-18 in modo da poter vedere i conteggi dei riferimenti
cambiare quando creiamo ed eliminiamo riferimenti a `Rc<List>` in `a`.

Nel Listato 15-19, modificheremo `main` in modo che abbia un ambito interno attorno alla lista `c`;
poi potremo vedere come cambia il conteggio dei riferimenti quando `c` esce dall'ambito.

<Listing number="15-19" file-name="src/main.rs" caption="Stampa del conteggio dei riferimenti">

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-19/src/main.rs:here}}
```

</Listing>

In ogni punto del programma in cui il conteggio dei riferimenti cambia, stampiamo il
conteggio dei riferimenti, che otteniamo chiamando la funzione `Rc::strong_count`. Questa
funzione si chiama `strong_count` anziché `count` perché il tipo `Rc<T>`
ha anche un `weak_count`; vedremo a cosa serve `weak_count` in ["Prevenire
i cicli di riferimento utilizzando `Weak<T>`”][preventing-ref-cycles]<!-- ignore -->.

Questo codice stampa quanto segue:

```console
{{#include ../listings/ch15-smart-pointers/listing-15-19/output.txt}}
```

Possiamo vedere che `Rc<List>` in `a` ha un conteggio dei riferimenti iniziale pari a 1; quindi
ogni volta che chiamiamo `clone`, il conteggio aumenta di 1. Quando `c` esce dall'ambito,
il conteggio diminuisce di 1. Non dobbiamo chiamare una funzione per diminuire il
conteggio dei riferimenti, come dobbiamo chiamare `Rc::clone` per aumentarlo: l'implementazione del tratto `Drop` diminuisce il conteggio dei riferimenti
automaticamente quando un valore `Rc<T>` esce dall'ambito.

Ciò che non possiamo vedere in questo esempio è che quando `b` e poi `a` escono dall'ambito
alla fine di `main`, il conteggio è 0 e `Rc<List>` viene ripulito
completamente. L'utilizzo di `Rc<T>` consente a un singolo valore di avere più proprietari e
il conteggio garantisce che il valore rimanga valido finché uno qualsiasi dei proprietari
esiste ancora.

Tramite riferimenti immutabili, `Rc<T>` consente di condividere dati tra più
parti del programma in sola lettura. Se `Rc<T>` consentisse di avere anche più
riferimenti mutabili, si potrebbe violare una delle regole di prestito discusse
nel Capitolo 4: più prestiti mutabili nello stesso posto possono causare conflitti di dati
e incongruenze. Ma poter mutare i dati è molto utile! Nella prossima
sezione, discuteremo il pattern di mutabilità interna e il tipo `RefCell<T>`
che è possibile utilizzare insieme a `Rc<T>` per lavorare con questa
restrizione di immutabilità.
[preventing-ref-cycles]: ch15-06-reference-cycles.html#preventing-reference-cycles-turning-an-rct-into-a-weakt
